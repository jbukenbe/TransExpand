function problem = svd_approx(problem)
% This function takes a generic problem structure input, and outputs either
% the information needed to sample future scenarios and make related
% approximations, or it outputs the approximations to unobserved scenarios
% along with the approximate U values.

%History            
%Version    Date        Who     Summary
%1          02/19/2018  JesseB  Initial Version


%% Initialization Data
LF_n = problem.LF_n;
scen_n = problem.LF_n*problem.samp_per;

%% Initialize approximation tools for future use if needed

% mean center scenario data
problem.mean_scen_cost = mean(problem.scen_op_cost);
A = problem.scen_op_cost - problem.mean_scen_cost;

% select scenarios from svd latent factors
[~, S, V] = svd(A);
[~,factor_id] = sort(abs(V(:,1:LF_n)),'descend');
factor_id = unique(factor_id','stable'); 
best_scen = factor_id(1:scen_n);

% find approximation matricies
X = (S(1:LF_n,1:LF_n)*V(best_scen,1:LF_n)')';
%H = V(:,1:LF_n)*S(1:LF_n,1:LF_n)*inv(X'*X)*X';

% output data
problem.svd.s_values = S ;
problem.svd.directions = V;
problem.svd.X = X;
problem.svd.hat = H;
problem.svd.latent_scen = best_scen;
problem.svd.filler_scen = setdiff(1:problem.scen.n,problem.svd.latent_scen);


%% Approximate unobserved scenarios if needed
% create simulated secondary set from crossval problem
partial_vec = cross_val_prob;
partial_vec(:,problem.svd.filler_scen) = 0;

% mean center partial input vector
partial_vec(:,best_scen) = partial_vec(:,best_scen) - problem.mean_scen_cost(best_scen);

% fill missing values with approximation Hat matrix
approx_out = H*partial_vec(:,best_scen)' + problem.mean_scen_cost;

% replace known values
approx_out(:,best_scen) = partial_vec(:,best_scen);


%% Crossvalidate Results
% Compare with pre-calculated crossvalidation set
err_matrix = approx_out - cross_val_prob.scen_cost;
err_percent = err_matrix./cross_val_prob.scen_cost;

%max err
%best plan difference
%cvar

problem.second_samp_runtime = cross_val_prob.runtime;

problem.approx_cost;
problem.actual_cost;
problem.mean_abs_percent_err = mean(max(abs(err_percent)));
problem.err_sum_squares = norm(err_matrix, 'fro');
problem.r_squared_est = sum(S(1:LF_n,1:LF_n))/sum(S);
problem.obs_r_squaree =1-(problem.err_sum_squares/norm(cross_val_prob.scen_cost,'fro'));

end